# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_export.ipynb.

#nbdev_cell auto 0
__all__ = ['extract_comments', 'NotebookProcessor', 'ModuleMaker', 'relative_import', 'absolute_import', 'update_import', 'ExportModuleProcessor', 'nbdev_build_lib']


#nbdev_cell ../nbs/01_export.ipynb 2
#export
from .read import *

from .imports import *
from fastcore.script import *

from collections import defaultdict
import ast


#nbdev_cell ../nbs/01_export.ipynb 7
#export
def extract_comments(ss):
    "Take leading comments from lines of code in `ss`, remove `#`, and split"
    ss = ss.splitlines()
    first_code = first(i for i,o in enumerate(ss) if re.match('\s*[^#\s]', o))
    return L((s.strip()[1:]).strip().split() for s in ss[:first_code]).filter()


#nbdev_cell ../nbs/01_export.ipynb 10
#export
class NotebookProcessor:
    "Base class for nbdev notebook processors"
    def __init__(self, path, debug=False): self.nb,self.path,self.debug = read_nb(path),Path(path),debug


#nbdev_cell ../nbs/01_export.ipynb 16
#export
@patch
def process_comment(self:NotebookProcessor, comment, cell):
    cmd,*args = comment
    cmd = f"{cmd}_{cell.cell_type}"
    if self.debug: print(cmd, args)
    if not hasattr(self, cmd): return
    try: getattr(self,cmd)(comment,cell, *args)
    except TypeError: pass


#nbdev_cell ../nbs/01_export.ipynb 19
#export
@patch
def process_cell(self:NotebookProcessor, cell):
    comments = extract_comments(cell.source)
    if not comments: return self.no_cmd(cell)
    for comment in comments: self.process_comment(comment, cell)
    return cell

@patch
def no_cmd(self:NotebookProcessor, cell): return cell


#nbdev_cell ../nbs/01_export.ipynb 22
#export
@patch
def process(self:NotebookProcessor):
    "Process all cells with `process_cell` and replace `self.nb.cells` with result"
    for i in range_of(self.nb.cells): self.nb.cells[i] = self.process_cell(self.nb.cells[i])


#nbdev_cell ../nbs/01_export.ipynb 27
#export
class ModuleMaker:
    "Helper class to create exported library from notebook source cells"
    def __init__(self, dest, name, nb_path, is_new=True):
        dest,nb_path = Path(dest),Path(nb_path)
        store_attr()
        self.fname = dest/(name.replace('.','/') + ".py")
        if is_new: dest.mkdir(parents=True, exist_ok=True)
        else: assert self.fname.exists(), f"{self.fname} does not exist"
        self.dest2nb = os.path.relpath(nb_path.absolute(), dest.absolute())
        self.hdr = cell_header(self.dest2nb, Config().path('lib_path'))


#nbdev_cell ../nbs/01_export.ipynb 30
#export
_def_types = (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)
_assign_types = (ast.AnnAssign, ast.Assign, ast.AugAssign)

def _val_or_id(it): return [getattr(o, 'value', getattr(o, 'id', None)) for o in it.value.elts]
def _all_targets(a): return L(a.id) if hasattr(a,'id') else L(getattr(a,'elts',None)).attrgot('id')
def _want_def(o):
    return isinstance(o, _def_types) and not any(d for d in o.decorator_list if d.id.startswith('patch'))

@patch
def make_all(self:ModuleMaker, cells):
    "Create `__all__` with all exports in `cells`"
    if cells is None: return ''
    parsed = cells.attrgot('parsed').concat()
    # functions and classes
    defs = L(parsed).filter(_want_def).attrgot('name')

    # assignment targets (NB: can be multiple, e.g. "a=b=c", and/or destructuring e.g "a,b=(1,2)")
    assigns = parsed.filter(bind(isinstance, arg0, _assign_types))
    assign_targs = L(L(assn.targets).map(_all_targets).concat() for assn in assigns).concat()

    # remove private (i.e starts with "_")
    exports = (defs+assign_targs).filter(lambda o: o and o[0]!='_')

    # include anything mentioned in "_all_", even if otherwise private
    # NB: "_all_" can include strings (names), or symbols, so we look for "id" or "value"
    all_assigns = assigns.filter(lambda o: getattr(o.targets[0],'id',None)=='_all_')
    all_vals = all_assigns.map(_val_or_id).concat()
    return (exports+all_vals).unique()


#nbdev_cell ../nbs/01_export.ipynb 34
#export
def relative_import(name, fname, level=0):
    "Convert a module `name` to a name relative to `fname`"
    assert not level
    sname = name.replace('.','/')
    if not(os.path.commonpath([sname,fname])): return name
    rel = os.path.relpath(sname, fname)
    if rel==".": return "."
    res = rel.replace(f"..{os.path.sep}", ".")
    return "." + res.replace(os.path.sep, ".")


#nbdev_cell ../nbs/01_export.ipynb 36
#export
def absolute_import(name, fname, level):
    "Unwarps a relative import in `name` according to `mod_name`"
    if not level: return name
    mods = fname.split(os.path.sep)
    if not name: return '.'.join(mods)
    return '.'.join(mods[:len(mods)-level+1]) + f".{name}"


#nbdev_cell ../nbs/01_export.ipynb 38
#export
def update_import(source, tree, libname, f):
    imps = L(tree).filter(risinstance(ast.ImportFrom))
    if not imps: return
    src = source.splitlines(True)
    for imp in imps:
        nmod = f(imp.module, libname, imp.level)
        lin = imp.lineno-1
        sec = src[lin][imp.col_offset:imp.end_col_offset]
        newsec = re.sub(f"(from +){'.'*imp.level}{imp.module}", fr"\1{nmod}", sec)
        src[lin] = src[lin].replace(sec,newsec)
    return src

@patch
def import2relative(cell:NbCell, libname):
    if not getattr(cell,'parsed',None): return
    src = update_import(cell.source, cell.parsed, libname, relative_import)
    if src: cell.set_source(src)


#nbdev_cell ../nbs/01_export.ipynb 40
#export
@patch
def make(self:ModuleMaker, cells, all_cells=None):
    "Write module containing `cells` with `__all__` generated from `all_cells`"
    for cell in all_cells: cell.import2relative(Config().lib_name)
    if not self.is_new: return self._make_exists(cells, all_cells)
    self.fname.parent.mkdir(exist_ok=True, parents=True)
    _all = self.make_all(all_cells)
    trees = cells.attrgot('parsed')
    try: last_future = max(i for i,tree in enumerate(trees) if any(
         isinstance(t,ast.ImportFrom) and t.module=='__future__' for t in tree))+1
    except ValueError: last_future=0
    with self.fname.open('w') as f:
        f.write(f"# AUTOGENERATED! DO NOT EDIT! File to edit: {self.dest2nb}.\n\n")
        export_cells(cells[:last_future], self.hdr, f, 0)
        f.write(create_all_cell(_all))
        export_cells(cells[last_future:], self.hdr, f, 1)


#nbdev_cell ../nbs/01_export.ipynb 44
#export
@patch
def _make_exists(self:ModuleMaker, cells, all_cells=None):
    "`make` for `is_new=False`"
    with self.fname.open() as f: curr = f.read().splitlines(True)
    if all_cells:
        all_loc = first(i for i,o in enumerate(curr) if o.startswith('__all__'))
        if all_loc is None: _all,all_loc,curr = [],0,['\n','#nbdev_cell auto 0\n']+curr
        else: _all = eval(re.findall('\s*=\s*(.*)', curr[all_loc])[0])
        _all += self.make_all(all_cells)
        curr[all_loc] = f"__all__ = {list(_all)}"
    with self.fname.open('w') as f:
        f.write("\n".join(curr))
        export_cells(cells, self.hdr, f)


#nbdev_cell ../nbs/01_export.ipynb 49
#export
class ExportModuleProcessor(NotebookProcessor):
    "A `NotebookProcessor` which exports code to a module"
    def __init__(self, path, dest, mod_maker=ModuleMaker, debug=False):
        dest = Path(dest)
        store_attr()
        super().__init__(path,debug=debug)

    def process(self):
        self.modules,self.in_all = defaultdict(L),defaultdict(L)
        super().process()


#nbdev_cell ../nbs/01_export.ipynb 52
#export
@patch
def default_exp_code(self:ExportModuleProcessor, comment, cell, exp_to): self.default_exp = exp_to


#nbdev_cell ../nbs/01_export.ipynb 55
#export
@patch
def exporti_code(self:ExportModuleProcessor, comment, cell, exp_to=None):
    mod = ifnone(exp_to, '#')
    self.modules[mod].append(cell)
    return mod


#nbdev_cell ../nbs/01_export.ipynb 58
#export
@patch
def export_code(self:ExportModuleProcessor, comment, cell, exp_to=None):
    mod = self.exporti_code(comment, cell, exp_to=exp_to)
    self.in_all[mod].append(cell)
ExportModuleProcessor.exports_code = ExportModuleProcessor.export_code


#nbdev_cell ../nbs/01_export.ipynb 60
#export
@patch
def create_modules(self:ExportModuleProcessor):
    self.process()
    for mod,cells in self.modules.items():
        all_cells = self.in_all[mod]
        name = self.default_exp if mod=='#' else mod
        mm = self.mod_maker(dest=self.dest, name=name, nb_path=self.path, is_new=mod=='#')
        mm.make(cells, all_cells)


#nbdev_cell ../nbs/01_export.ipynb 68
#export
def _update_baseurl(path=None):
    "Add or update `baseurl` in `_config.yml` for the docs"
    _re_baseurl = re.compile('^baseurl\s*:.*$', re.MULTILINE)
    path = Path(ifnone(path, Config().doc_path))
    fname = path/'_config.yml'
    if not fname.exists(): return
    code = fname.read_text()
    if _re_baseurl.search(code) is None: code = code + f"\nbaseurl: {Config().doc_baseurl}"
    else: code = _re_baseurl.sub(f"baseurl: {Config().doc_baseurl}", code)
    fname.write_text(code)

def _use_nb(p): return not p.name.startswith('_') and '.ipynb_checkpoints' not in p.parts


#nbdev_cell ../nbs/01_export.ipynb 69
#export
@call_parse
def nbdev_build_lib(
    nbs:Param("Glob specifiying notebooks to export (defaults to all nbs in `nbs_path`)", str)=None,
    dest:Param("Destination for library (defaults to `lib_path`)", str)=None):
    "Convert notebooks matching `nbs` to modules"
    cfg = Config()
    dest = cfg.config_file.parent/(ifnone(dest, cfg.lib_path))
    if os.environ.get('IN_TEST',0): return
    if nbs is None: files = L(cfg.path('nbs_path').glob('*.ipynb')).filter(_use_nb)
    else: files = glob.glob(nbs)
    for file in files: ExportModuleProcessor(file, dest).create_modules()
    if not cfg.get('extension',False):
        _update_baseurl()
        add_init(dest)


