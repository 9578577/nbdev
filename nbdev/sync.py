# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_sync.ipynb.

#nbdev_cell auto 0
__all__ = ['nbdev_update_lib']


#nbdev_cell ../nbs/02_sync.ipynb 3
#export
from .read import *
from .export import *

from .imports import *
from fastcore.script import *

import nbformat,ast
from nbformat.sign import NotebookNotary


#nbdev_cell ../nbs/02_sync.ipynb 4
#export
_re_import = re.compile("from\s+\S+\s+import\s+\S")

def _to_absolute(code, libname):
    if not _re_import.search(code): return code
    res = update_import(code, ast.parse(code).body, libname, absolute_import)
    if not res: return code
    return ''.join(res)

def _update_lib(nbname, nb_locs):
    libname = Config().lib_name
    nbtxt = Path(nbname).read_text()
    nb = nbformat.reads(nbtxt, as_version=4)
    for nbn,cellid,code in nb_locs:
        assert nbn==nbname,(nbn,nbname)
        code = code[code.find("\n")+1:]
        nb.cells[int(cellid)].source = _to_absolute(code, libname)

    NotebookNotary().sign(nb)
    nbformat.write(nb, 'tmp/tmp.ipynb', version=4)


#nbdev_cell ../nbs/02_sync.ipynb 5
#export
@call_parse
def nbdev_update_lib(fname:Param("A python module name to convert", str)):
    "Propagates any change in the modules matching `fname` to the notebooks that created them"
    if os.environ.get('IN_TEST',0): return
    fname = Path(fname)
    code = fname.read_text()
    split_str = "\n#nbdev_cell "
    code_cells = code.split(split_str)[1:]
    locs = L(s.splitlines()[0].split()+[s.strip("\n")]
             for s in code_cells if not s.startswith('auto '))
    for nbname,nb_locs in groupby(locs, itemgetter(0)).items(): _update_lib(nbname, nb_locs)


