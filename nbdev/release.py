# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/10_release.ipynb (unless otherwise specified).

__all__ = ['GH_HOST', 'FastRelease']

# Cell
from datetime import datetime
from textwrap import fill
from urllib.request import Request,urlopen
from urllib.error import HTTPError

# Cell
GH_HOST = "https://api.github.com"

# Cell
def _issue_txt(issue):
    res = f'- {issue["title"].strip()} ([#{issue["number"]}]({issue["url"]}))\n'
    body = issue['body']
    if not body: return res
    return res + fill(body.strip(), initial_indent="  - ", subsequent_indent="    ") + "\n"

def _issues_txt(iss, label):
    if not iss: return ''
    res = f"### {label}\n\n"
    return res + '\n'.join(map(_issue_txt, iss))

# Cell
class FastRelease:
    def __init__(self, owner=None, repo=None, token=None, **groups):
        "Create CHANGELOG.md from GitHub issues"
        if not groups: groups = dict(breaking="Breaking Changes", enhancement="New Features", bug="Bugs Squashed")
        cfg = Config()
        os.chdir(cfg.config_file.parent)
        if not owner: owner = cfg.user
        if not repo:  repo  = cfg.lib_name
        if not token: token = Path('token').read_text().strip()
        self.owner,self.repo,self.token,self.groups = owner,repo,token,groups
        self.headers = { 'Authorization' : f'token {token}' }
        self.repo_url = f"{GH_HOST}/repos/{owner}/{repo}"

    def _get(self, path, complete=False):
        if not complete: path = f"{self.repo_url}/{path}"
        with urlopen(Request(path, headers=self.headers)) as res: return json.loads(res.read())

    def _tag_date(self, tag):
        try: tag_d = self._get(f"git/ref/tags/{tag}")
        except HTTPError: raise Exception(f"Failed to find tag {tag}")
        commit_d = self._get(tag_d["object"]["url"], True)
        self.commit_date = commit_d["committer"]["date"].replace('Z', '+00:00')
        return self.commit_date

    def _issues(self, label):
        return self._get(f"issues?state=closed&sort=created&filter=all&since={self.commit_date}&labels={label}")

    def _issue_groups(self): return map(self._issues, self.groups.keys())
    def _latest_release(self): return self._get("releases/latest")["tag_name"]

    def changelog(self, debug=False):
        "Create the CHANGELOG.md file, or return the proposed text if `debug` is `True`"
        fn = 'CHANGELOG.md'
        shutil.copy(fn, fn+".bak")
        txt = Path(fn).read_text()
        marker = '<!-- do not remove -->\n'
        ver = self._latest_release()
        self._tag_date(ver)
        res = f"## {ver}\n"
        issues = self._issue_groups()
        res += '\n'.join(_issues_txt(*o) for o in zip(issues, self.groups.values()))
        res = txt.replace(marker, marker+res)
        if debug: return res
        else: Path(fn).write_text(res)